//
// Generated by JTB 1.3.2
//
package visitor;

import syntaxtree.*;
import java.util.*;

class ObjectTable {
	HashMap<String, Integer> varOffset;
	HashMap<String, Integer> vTable;

	public ObjectTable() {
		varOffset = new HashMap<String, Integer>();
		vTable = new HashMap<String, Integer>();
	}
}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirstPass2<R, A> extends GJDepthFirst<R, A> {
	boolean debug = false;
	HashMap<String, Integer> localVarTable = new HashMap<String, Integer>();
	HashMap<String, SymbolTable> Table;
	HashMap<String, ObjectTable> objectTable = new HashMap<String, ObjectTable>();
	int tempC = 0;
	String curClassName = "";
	String curMethodName = null;
	int label = 0;

	//
	// Auto class visitors--probably don't need to be overridden.
	//
	public R visit(NodeList n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeListOptional n, A argu) {
		if (n.present()) {
			R _ret = null;
			int _count = 0;
			LinkedList<R> list = new LinkedList<R>();

			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				list.add(e.nextElement().accept(this, argu));
				_count++;
			}
			return (R) list;
		} else
			return null;
	}

	public R visit(NodeOptional n, A argu) {
		if (n.present())
			return n.node.accept(this, argu);
		else
			return null;
	}

	public R visit(NodeSequence n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeToken n, A argu) {
		return null;
	}
	
	int isOverRiding(String startClass, String method, ObjectTable target) {
		String classIter = startClass;
		while (classIter != null) {
			SymbolTable t = Table.get(classIter);
			if (t.method.containsKey(method)) {
				int offset = target.vTable.get(classIter + "_" + method);
				target.vTable.remove(classIter + "_" + method);
				return offset;
			}
			classIter = t.parenClass;
		}
		return -1;
	}

	void generateObjectTable(String className, ObjectTable curTable) {
		SymbolTable classTable = Table.get(className);
		if (classTable.parenClass != null)
			generateObjectTable(classTable.parenClass, curTable);

		int counter_var = 4 * (curTable.varOffset.size() + 1);
		int counter_m = curTable.vTable.size();
		for (String vars : classTable.vars.keySet()) {
			curTable.varOffset.put(className + "_" + vars, counter_var);
			counter_var += 4;
		}
		for (String method : classTable.method.keySet()) {
			int counter = isOverRiding(classTable.parenClass, method, curTable);
			if (counter != -1) {
				curTable.vTable.put(className + "_" + method, counter);
			} else {
				curTable.vTable.put(className + "_" + method, counter_m);
				counter_m += 4;
			}
		}
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	
	public R visit(Goal n, A argu) {

		R _ret = null;
		Table = (HashMap<String, SymbolTable>) argu;
		for (String class_ : Table.keySet()) {
			ObjectTable curTable = new ObjectTable();
			generateObjectTable(class_, curTable);
			objectTable.put(class_, curTable);
		}
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static" f5
	 * -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]" f11 ->
	 * Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 -> "}" f16 ->
	 * "}"
	 */
	public R visit(MainClass n, A argu) {
		R _ret = null;
		System.out.println("MAIN\n");
		n.f0.accept(this, argu);
		curClassName = (String) n.f1.accept(this, argu);
		curMethodName = "main";
		SymbolTable curClass = Table.get(curClassName);
		SymbolTable methodTable = curClass.method.get("main");
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		argu = (A) methodTable;
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		n.f8.accept(this, argu);
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		n.f13.accept(this, argu);
		n.f14.accept(this, argu);
		n.f15.accept(this, argu);
		n.f16.accept(this, argu);
		curMethodName = null;

		System.out.println("END\n");
		return _ret;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public R visit(TypeDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4 ->
	 * ( MethodDeclaration() )* f5 -> "}"
	 */
	public R visit(ClassDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		curClassName = (String) n.f1.accept(this, argu);
		SymbolTable classTable = Table.get(curClassName);
		argu = (A) classTable;
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 -> "{"
	 * f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public R visit(ClassExtendsDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		curClassName = (String) n.f1.accept(this, argu);
		SymbolTable classTable = Table.get(curClassName);
		argu = (A) classTable;
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Type() f1 -> Identifier() f2 -> ";"
	 */
	public R visit(VarDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String varName = (String) n.f1.accept(this, argu);
		localVarTable.put(varName, tempC++);
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )* f8
	 * -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12 -> "}"
	 */
	public R visit(MethodDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String mName = (String) n.f2.accept(this, argu);
		curMethodName = mName;
		localVarTable = new HashMap<String, Integer>();
		tempC = 1;
		SymbolTable methodTable = ((SymbolTable) argu).method.get(mName);
		argu = (A) methodTable;
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		int nParams = tempC;
		System.out.println(curClassName + "_" + mName + " [" + nParams + "]\n");
		System.out.println(" BEGIN\n");
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		n.f8.accept(this, argu);
		System.out.println(" RETURN ");
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		n.f11.accept(this, argu);
		System.out.println(" END\n");
		n.f12.accept(this, argu);
		curMethodName = null;
		return _ret;
	}

	/**
	 * f0 -> FormalParameter() f1 -> ( FormalParameterRest() )*
	 */
	public R visit(FormalParameterList n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Type() f1 -> Identifier()
	 */
	public R visit(FormalParameter n, A argu) {
		R _ret = null;
		String type = (String) n.f0.accept(this, argu);
		String varName = (String) n.f1.accept(this, argu);
		localVarTable.put(varName, tempC++);
		return _ret;
	}

	/**
	 * f0 -> "," f1 -> FormalParameter()
	 */
	public R visit(FormalParameterRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> ArrayType() | BooleanType() | IntegerType() | Identifier()
	 */
	public R visit(Type n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "int" f1 -> "[" f2 -> "]"
	 */
	public R visit(ArrayType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		_ret = (R) "int[]";
		return _ret;
	}

	/**
	 * f0 -> "boolean"
	 */
	public R visit(BooleanType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> "int"
	 */
	public R visit(IntegerType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public R visit(Statement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public R visit(Block n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	int getVarOffset(String varName, String className) {
		String classIter = className;
		ObjectTable target = objectTable.get(className);
		while (classIter != null) {
			SymbolTable t = Table.get(classIter);
			if (t.vars.containsKey(varName)) {
				return target.varOffset.get(classIter + "_" + varName);
			}
			classIter = t.parenClass;
		}
		return -1;
	}

	/**
	 * f0 -> Identifier() f1 -> "=" f2 -> Expression() f3 -> ";"
	 */
	public R visit(AssignmentStatement n, A argu) {
		R _ret = null;
		String var = (String) n.f0.accept(this, argu);

		if (localVarTable.containsKey(var)) {
			System.out.println("\t MOVE TEMP " + localVarTable.get(var));
		} else {
			System.out.println("\t HSTORE TEMP 0 " + getVarOffset(var, curClassName));
		}
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public R visit(ArrayAssignmentStatement n, A argu) {
		R _ret = null;
		String var = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);

		if (!localVarTable.containsKey(var)) {

			System.out.println("\t HSTORE PLUS");
			int t1 = tempC++;
			int t2 = tempC++;
			int t3 = tempC++;

			System.out.println(" BEGIN \n\t HLOAD TEMP " + t1 + " TEMP 0 " + getVarOffset(var, curClassName));

			System.out.println(" RETURN TEMP " + t1 + " END");

			System.out.println(" PLUS \n BEGIN \n\t MOVE TEMP " + t2 + " TIMES ");
			n.f2.accept(this, argu);

			System.out.println("4 \n\t HLOAD TEMP " + t3);

			System.out.println(" BEGIN \n\t HLOAD TEMP " + t1 + " TEMP 0 " + getVarOffset(var, curClassName));

			System.out.println(" RETURN TEMP " + t1 + " END\n 0");
			int l1 = label++;

			System.out.println("CJUMP  MINUS  1  TIMES LE 0 TEMP " + t2 + " LE TEMP " + t2 + " MINUS TIMES TEMP " + t3
					+ " 4 1 L" + l1);

			System.out.println("\t ERROR \nL" + l1 + "\t NOOP \n RETURN TEMP " + t2 + " \n END\n 4  0");
		} else {

			System.out.println("\t HSTORE PLUS");
			int t2 = tempC++;
			int t3 = tempC++;

			System.out.println(" TEMP " + localVarTable.get(var));

			System.out.println(" PLUS \n BEGIN \n\t MOVE TEMP " + t2 + " TIMES ");
			n.f2.accept(this, argu);

			System.out.println("4 \n\t HLOAD TEMP " + t3);

			System.out.println(" TEMP " + localVarTable.get(var) + " 0");
			int l1 = label++;

			System.out.println("CJUMP  MINUS  1  TIMES LE 0 TEMP " + t2 + " LE TEMP " + t2 + " MINUS TIMES TEMP " + t3
					+ " 4 1 L" + l1);

			System.out.println("\t ERROR \nL" + l1 + "\t NOOP \n RETURN TEMP " + t2 + " \n END\n 4  0");
		}

		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> IfthenElseStatement() | IfthenStatement()
	 */
	public R visit(IfStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public R visit(IfthenStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);

		System.out.println(" \t CJUMP ");
		n.f2.accept(this, argu);
		int jmpLabel = label;

		System.out.println(" L" + label + " NOOP");
		label++;
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);

		System.out.println(" L" + jmpLabel + " NOOP");
		return _ret;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public R visit(IfthenElseStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);

		System.out.println(" \t CJUMP ");
		n.f2.accept(this, argu);
		int ifFalse = label;

		System.out.println(" L" + label + " NOOP");
		label++;
		int endLabel = label++;
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);

		System.out.println(" JUMP L" + endLabel);

		System.out.println(" L" + ifFalse);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);

		System.out.println(" L" + endLabel + " NOOP");
		return _ret;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public R visit(WhileStatement n, A argu) {
		R _ret = null;
		int startLabel = label;

		System.out.println(" L" + label + " \t CJUMP ");
		label++;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		int endLabel = label;

		System.out.println(" L" + label + " NOOP");
		label++;
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);

		System.out.println(" JUMP L" + startLabel);

		System.out.println(" L" + endLabel + " NOOP");
		return _ret;
	}

	/**
	 * f0 -> "if(pass2) System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")"
	 * f4 -> ";"
	 */
	public R visit(PrintStatement n, A argu) {
		R _ret = null;

		System.out.println(" PRINT ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> OrExpression() | AndExpression() | CompareExpression() |
	 * neqExpression() | PlusExpression() | MinusExpression() | TimesExpression() |
	 * DivExpression() | ArrayLookup() | ArrayLength() | MessageSend() |
	 * PrimaryExpression()
	 */
	public R visit(Expression n, A argu) {
		R _ret = null;
		return n.f0.accept(this, argu);
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public R visit(AndExpression n, A argu) {
		R _ret = null;

		System.out.println(" TIMES ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "||" f2 -> PrimaryExpression()
	 */
	public R visit(OrExpression n, A argu) {
		R _ret = null;
		System.out.println(" LE 1 PLUS ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "<=" f2 -> PrimaryExpression()
	 */
	public R visit(CompareExpression n, A argu) {
		R _ret = null;
		System.out.println(" LE ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "!=" f2 -> PrimaryExpression()
	 */
	public R visit(neqExpression n, A argu) {
		R _ret = null;
		System.out.println(" NE ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public R visit(PlusExpression n, A argu) {
		R _ret = null;
		System.out.println(" PLUS ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public R visit(MinusExpression n, A argu) {
		R _ret = null;
		System.out.println(" MINUS ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public R visit(TimesExpression n, A argu) {
		R _ret = null;

		System.out.println(" TIMES ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "/" f2 -> PrimaryExpression()
	 */
	public R visit(DivExpression n, A argu) {
		R _ret = null;
		System.out.println(" DIV ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public R visit(ArrayLookup n, A argu) {
		R _ret = null;

		System.out.println(" BEGIN\t MOVE TEMP " + tempC);
		int t1 = tempC++;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		int t2 = tempC++;

		System.out.println("\t MOVE TEMP " + t2);
		n.f2.accept(this, argu);
		int t3 = tempC++;
		int t4 = tempC++;
		int l1 = label++;

		System.out.println("\t CJUMP TIMES LE 0 TEMP " + t2 + " LE TEMP " + t2 + " MINUS BEGIN HLOAD TEMP " + t3
				+ " TEMP " + t1 + " 0   RETURN TEMP " + t3 + " END 1 L" + l1);

		System.out.println("\t HLOAD TEMP " + t4 + " PLUS TEMP " + t1 + " PLUS TIMES TEMP " + t2 + " 4 4 0 ");
		int l2 = label++;

		System.out.println("\tJUMP L" + l2 + "\n");

		System.out.println(" L" + l1 + "\t NOOP\n\t ERROR\n L" + l2 + "\t NOOP\n");

		System.out.println(" RETURN TEMP " + t4 + " END \n");
		n.f3.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public R visit(ArrayLength n, A argu) {
		R _ret = null;
		int t1 = tempC++;

		System.out.println(" BEGIN");

		System.out.println("\t MOVE TEMP " + t1);
		n.f0.accept(this, argu);
		int t2 = tempC++;

		System.out.println("\t HLOAD TEMP " + t2 + " TEMP " + t1 + " 0");

		System.out.println(" RETURN TEMP " + t2 + " END");
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return (R) "int";
	}

	int getMethodOffset(String mName, String className) {
		String classIter = className;
		ObjectTable target = objectTable.get(className);
		while (classIter != null) {
			SymbolTable t = Table.get(classIter);
			if (t.method.containsKey(mName)) {
				return target.vTable.get(classIter + "_" + mName);
			}
			classIter = t.parenClass;
		}
		return -1;
	}

	String getReturnType(String mName, SymbolTable cTable) {
		while (cTable != null) {
			if (cTable.retType.containsKey(mName))
				return cTable.retType.get(mName);
			cTable = Table.get(cTable.parenClass);
		}
		return null;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public R visit(MessageSend n, A argu) {
		R _ret = null;
		int t1 = tempC++;

		System.out.println(" CALL \n BEGIN\t MOVE TEMP " + t1);
		String cName = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String mName = (String) n.f2.accept(this, argu);
		int t2 = tempC++;

		System.out.println("\t HLOAD TEMP " + t2 + " TEMP " + t1 + " 0");
		int t3 = tempC++;

		System.out.println("\t HLOAD TEMP " + t3 + " TEMP " + t2 + " " + getMethodOffset(mName, cName));

		System.out.println("RETURN TEMP " + t3 + " END");

		System.out.println(" ( TEMP " + t1 + " ");
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);

		System.out.println(")");
		return (R) getReturnType(mName, Table.get(cName));
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public R visit(ExpressionList n, A argu) {
		R _ret = null;
		LinkedList<String> list = new LinkedList<String>();
		String fp = (String) n.f0.accept(this, argu);
		R otherFp = n.f1.accept(this, argu);
		if (otherFp == null) {
			list.addFirst(fp);
			return (R) list;
		}
		list = (LinkedList<String>) otherFp;
		list.addFirst(fp);
		return (R) list;
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public R visit(ExpressionRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		return _ret;
	}

	String idMatch(String id, SymbolTable T) {
		SymbolTable iter = T;
		while (T != null) {
			if (T.vars.containsKey(id))
				return T.vars.get(id);
			T = Table.get(T.parenClass);
		}
		return null;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public R visit(PrimaryExpression n, A argu) {
		R _ret = null;
		String t = (String) n.f0.accept(this, argu);
		if (n.f0.which == 3) {
			if (localVarTable.containsKey(t))
				System.out.println(" TEMP " + localVarTable.get(t));
			else {
				int t1 = tempC++;
				System.out.println("BEGIN \n\t HLOAD TEMP " + t1 + " TEMP 0 " + getVarOffset(t, curClassName));
				System.out.println(" RETURN TEMP " + t1 + " END");
			}
			if (Table.containsKey(t)) // class type
				return (R) t;
			return (R) idMatch(t, (SymbolTable) argu);
		}
		return (R) t;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public R visit(IntegerLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println(n.f0.toString());
		return (R) "int";
	}

	/**
	 * f0 -> "true"
	 */
	public R visit(TrueLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println(" 1");
		return (R) "boolean";
	}

	/**
	 * f0 -> "false"
	 */
	public R visit(FalseLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println(" 0");
		return (R) "boolean";
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public R visit(Identifier n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) n.f0.toString();
	}

	/**
	 * f0 -> "this"
	 */
	public R visit(ThisExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println(" TEMP 0");
		return (R) curClassName;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public R visit(ArrayAllocationExpression n, A argu) {
		R _ret = null;
		int t1 = tempC++;
		System.out.println("BEGIN \n\t MOVE TEMP " + t1 + "\n ");
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		int t2 = tempC++;
		int l = label++;
		System.out.println(" CJUMP MINUS 1 LE 0 TEMP "+t1+" L"+l);
		System.out.println(" ERROR \n L"+l+" NOOP");
		
		System.out.println("\t MOVE TEMP " + t2 + " HALLOCATE TIMES PLUS TEMP " + t1 + " 1 4 ");
		// length in 0

		System.out.println("\t HSTORE TEMP " + t2 + " 0 TEMP " + t1);
		int t3 = tempC++;

		System.out.println("MOVE TEMP " + t3 + " 4");
		int l1 = label++;
		int l2 = label++;

		System.out.println(" L" + l1 + " \n \t CJUMP LE TEMP " + t3 + " MINUS TIMES PLUS TEMP " + t1 + " 1 4 1 L" + l2);

		System.out.println("\t HSTORE PLUS TEMP " + t2 + " TEMP " + t3 + " 0 0");

		System.out.println("\t MOVE TEMP " + t3 + " PLUS TEMP " + t3 + " 4 \n");

		System.out.println(" JUMP L" + l1 + "\n L" + l2 + " NOOP");

		System.out.println("RETURN TEMP " + t2 + " END \n");
		n.f4.accept(this, argu);
		return (R) "int[]";
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public R visit(AllocationExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t = (String) n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		ObjectTable curTable = objectTable.get(t);
		int structSize = (curTable.varOffset.size() + 1) * 4;
		int vTableSize = (curTable.vTable.size()) * 4;
		int t1 = tempC++;

		System.out.println(" BEGIN\n\tMOVE TEMP " + t1 + " HALLOCATE " + vTableSize);
		int t2 = tempC++;

		System.out.println("\tMOVE TEMP " + t2 + " HALLOCATE " + structSize);
		for (String mName : curTable.vTable.keySet())
			System.out.println("\tHSTORE TEMP " + t1 + " " + curTable.vTable.get(mName) + " " + mName);
		int t3 = tempC++;

		System.out.println("\tMOVE TEMP " + t3 + " 4");
		int l1 = label++;
		int l2 = label++;

		System.out.println("L" + l1 + "\t CJUMP  LE TEMP " + t3 + " " + (structSize - 1) + " L" + l2);

		System.out.println("\t HSTORE PLUS TEMP " + t2 + " TEMP " + t3 + " 0 0");

		System.out.println("\t MOVE TEMP " + t3 + "  PLUS TEMP " + t3 + " 4\n\tJUMP L" + l1);

		System.out.println("L" + l2 + "\tHSTORE TEMP " + t2 + " 0 TEMP " + t1);

		System.out.println(" RETURN TEMP " + t2 + " \n END \n");
		return (R) t;
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public R visit(NotExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println(" MINUS 1 ");
		String t = (String) n.f1.accept(this, argu);
		return (R) t;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public R visit(BracketExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Identifier() f1 -> ( IdentifierRest() )*
	 */
	public R visit(IdentifierList n, A argu) {
		R _ret = null;
		LinkedList<String> list = new LinkedList<String>();
		String fp = (String) n.f0.accept(this, argu);
		R otherFp = n.f1.accept(this, argu);
		if (otherFp == null) {
			list.addFirst(fp);
			return (R) list;
		}
		list = (LinkedList<String>) otherFp;
		list.addFirst(fp);
		return (R) list;
	}

	/**
	 * f0 -> "," f1 -> Identifier()
	 */
	public R visit(IdentifierRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		return _ret;
	}

}

