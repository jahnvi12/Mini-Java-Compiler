//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import visitor.GJDepthFirst.allocInfo;
import visitor.GJDepthFirst.regAlloc;

import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GenerateCode<R, A> implements GJVisitor<R, A> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	int stmtNo = 0;
	String curFuncName = null;
	int curTemp = -1;

	public class spillInfo {
		int stackIndex;

		public spillInfo() {
			stackIndex = -1;
		}

		public spillInfo(int st) {
			stackIndex = st;
		}
	}

	HashMap<String, HashMap<Integer, Integer>> start;

	// fnName -> (Temp -> RegAlloc)
	HashMap<String, HashMap<Integer, regAlloc>> funcRegAlloc = new HashMap<String, HashMap<Integer, regAlloc>>();

	// fnName -> MaxArgsCalled
	HashMap<String, Integer> maxArgsCalled = new HashMap<String, Integer>();

	// fnName -> maxTReg
	HashMap<String, Integer> maxTIndex = new HashMap<String, Integer>();

	// fnName -> maxSReg
	HashMap<String, Integer> maxSIndex = new HashMap<String, Integer>();

	// fnName -> numSpilledReg
	HashMap<String, Integer> numTempsSpilled = new HashMap<String, Integer>();

	public R visit(NodeList n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeListOptional n, A argu) {
		if (n.present()) {
			R _ret = null;
			int _count = 0;
			LinkedList<R> list = new LinkedList<R>();

			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				list.add(e.nextElement().accept(this, argu));
				_count++;
			}
			return (R) list;
		} else
			return null;
	}

	public R visit(NodeOptional n, A argu) {
		if (n.present()) {
			String label = (String) n.node.accept(this, argu);
			System.out.println(label);
			return (R) label;
		} else
			return null;
	}

	public R visit(NodeSequence n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeToken n, A argu) {
		return (R) n.tokenImage;
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> "MAIN" f1 -> StmtList() f2 -> "END" f3 -> ( Procedure() )* f4 -> <EOF>
	 */
	public R visit(Goal n, A argu) {

		allocInfo t = (allocInfo) argu;
		maxArgsCalled = t.maxArgsCalled;
		numTempsSpilled = t.numTempsSpilled;
		funcRegAlloc = t.funcRegAlloc;
		start = t.start;

		R _ret = null;
		n.f0.accept(this, argu);

		curFuncName = "MAIN";
		int third = maxArgsCalled.get("MAIN");
		int second = 0;
		if (third != -1)
			second += 10;
		else
			third = 0;
		second += numTempsSpilled.get("MAIN");

		System.out.println("MAIN [0] [" + second + "] [" + third + "]");
		n.f1.accept(this, argu);
		System.out.println("END");
		if (numTempsSpilled.get("MAIN") == 0)
			System.out.println("// NOTSPILLED");
		else
			System.out.println("// SPILLED");
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public R visit(StmtList n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	String getReg(int temp, int spillReg, spillInfo info) {

		HashMap<Integer, regAlloc> alloc = funcRegAlloc.get(curFuncName);
		regAlloc reg = alloc.get(temp);

		if (reg == null)
			return "v1";
		if (start.get(curFuncName).containsKey(temp))
			if (stmtNo < start.get(curFuncName).get(temp))
				return "v1";
		String print = reg.register;
		if (reg.spilled) {
			System.out.println("\t ALOAD v" + spillReg + " SPILLEDARG " + reg.stackIndex);
			info.stackIndex = reg.stackIndex;
			print = "v" + spillReg;
		}

		return print;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> StmtExp()
	 */
	public R visit(Procedure n, A argu) {
		stmtNo++;
		R _ret = null;

		curFuncName = (String) n.f0.accept(this, argu);
		// System.out.println(curFuncName + "-------->");
		// System.out.println("maxArgs: " + maxArgsCalled.get(curFuncName));
		// System.out.println("numTempsSpilled: " + numTempsSpilled.get(curFuncName));

		n.f1.accept(this, argu);
		int nParams = Integer.parseInt(n.f2.accept(this, argu) + "");

		int third = maxArgsCalled.get(curFuncName);
		int second = 8;
		if (third != -1)
			second += 10;
		else
			third = 0;
		second += numTempsSpilled.get(curFuncName);

		System.out.println(curFuncName + " [" + nParams + "] [" + second + "] [" + third + "]");

		int startIndex = (nParams - 4 > 0) ? nParams - 4 : 0;

		for (int i = 0; i < 8; i++)
			System.out.println("\t ASTORE SPILLEDARG " + (startIndex + i) + " s" + i);

		for (int i = 0; i < nParams; i++)
			if (i < 4) {
				spillInfo spill = new spillInfo();
				String reg = getReg(i, 0, spill);
				System.out.println("MOVE " + reg + " a" + i);
				if (spill.stackIndex != -1)
					System.out.println("\t ASTORE SPILLEDARG " + spill.stackIndex + " " + reg);

			}
		// System.out.println("\t MOVE s" + i + " a" + i);

		n.f3.accept(this, argu);
		n.f4.accept(this, argu);

		for (int i = 0; i < 8; i++)
			System.out.println("\t ALOAD s" + i + " SPILLEDARG " + (startIndex + i));
		System.out.println("END");
		if (numTempsSpilled.get(curFuncName) == 0 || numTempsSpilled.get(curFuncName) == (nParams - 4))
			System.out.println("// NOTSPILLED");
		else
			System.out.println("// SPILLED");
		return _ret;
	}

	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt() |
	 * HLoadStmt() | MoveStmt() | PrintStmt()
	 */
	public R visit(Stmt n, A argu) {
		stmtNo++;
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public R visit(NoOpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println("\t NOOP");
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public R visit(ErrorStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println("\t ERROR");
		return _ret;
	}

	/**
	 * f0 -> "CJUMP" f1 -> Temp() f2 -> Label()
	 */
	public R visit(CJumpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		int temp = Integer.parseInt(n.f1.accept(this, argu) + "");
		String label = (String) n.f2.accept(this, argu);

		String print = getReg(temp, 0, new spillInfo());

		System.out.println("\t CJUMP " + print + " " + label);
		return _ret;
	}

	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public R visit(JumpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String label = (String) n.f1.accept(this, argu);
		System.out.println("\t JUMP " + label);
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Temp() f2 -> IntegerLiteral() f3 -> Temp()
	 */
	public R visit(HStoreStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		int temp1 = Integer.parseInt(n.f1.accept(this, argu) + "");
		int offset = Integer.parseInt(n.f2.accept(this, argu) + "");
		int temp2 = Integer.parseInt(n.f3.accept(this, argu) + "");

		String t1 = getReg(temp1, 0, new spillInfo());
		String t2 = getReg(temp2, 1, new spillInfo());
		System.out.println("\t HSTORE " + t1 + " " + offset + " " + t2);

		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Temp() f2 -> Temp() f3 -> IntegerLiteral()
	 */
	public R visit(HLoadStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		int temp1 = Integer.parseInt(n.f1.accept(this, argu) + "");
		int temp2 = Integer.parseInt(n.f2.accept(this, argu) + "");
		int offset = Integer.parseInt(n.f3.accept(this, argu) + "");

		spillInfo s1 = new spillInfo();
		String t1 = getReg(temp1, 0, s1);
		String t2 = getReg(temp2, 1, new spillInfo());
		System.out.println("\t HLOAD " + t1 + " " + t2 + " " + offset);
		if (s1.stackIndex != -1)
			System.out.println("\t ASTORE SPILLEDARG " + s1.stackIndex + " " + t1);

		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Temp() f2 -> Exp()
	 */
	public R visit(MoveStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		curTemp = Integer.parseInt(n.f1.accept(this, argu) + "");
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public R visit(PrintStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		System.out.println("\t PRINT " + _ret);
		return _ret;
	}

	/**
	 * f0 -> Call() | HAllocate() | BinOp() | SimpleExp()
	 */
	public R visit(Exp n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		if (n.f0.which == 3) {
			spillInfo res = new spillInfo();
			String resTemp = getReg(curTemp, 0, res);
			if (res.stackIndex != -1)
				System.out.println("\t ASTORE SPILLEDARG " + res.stackIndex + " " + _ret);
			else
				System.out.println("\t MOVE " + resTemp + " " + _ret);
		}
		return _ret;
	}

	/**
	 * f0 -> "BEGIN" f1 -> StmtList() f2 -> "RETURN" f3 -> SimpleExp() f4 -> "END"
	 */
	public R visit(StmtExp n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		stmtNo++;
		_ret = n.f3.accept(this, argu);
		System.out.println("\t MOVE v0 " + _ret);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "CALL" f1 -> SimpleExp() f2 -> "(" f3 -> ( Temp() )* f4 -> ")"
	 */
	public R visit(Call n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String fnReg = (String) n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		R argsT = n.f3.accept(this, argu);
		n.f4.accept(this, argu);

		int start = numTempsSpilled.get(curFuncName) + 8;
		if (curFuncName.equals("MAIN"))
			start -= 8;
		for (int i = 0; i < 10; i++)
			System.out.println("\t ASTORE SPILLEDARG " + (start + i) + " t" + i);

		LinkedList<String> args = new LinkedList<String>();

		if (argsT != null)
			args = (LinkedList<String>) argsT;

		for (int i = 0; i < args.size(); i++) {
			String aReg = getReg(Integer.parseInt(args.get(i)), 0, new spillInfo());
			if (i < 4)
				System.out.println("\t MOVE a" + i + " " + aReg);
			else
				System.out.println("\t PASSARG " + (i - 3) + " " + aReg);
		}
		System.out.println("\t CALL " + fnReg);

		spillInfo res = new spillInfo();
		String resTemp = getReg(curTemp, 0, res);

		for (int i = 0; i < 10; i++)
			System.out.println("\t ALOAD t" + i + " SPILLEDARG " + (start + i));

		if (res.stackIndex != -1)
			System.out.println("\t ASTORE SPILLEDARG " + res.stackIndex + "v0");
		else
			System.out.println("\t MOVE " + resTemp + " v0 ");
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public R visit(HAllocate n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t = (String) n.f1.accept(this, argu);

		spillInfo res = new spillInfo();
		String resTemp = getReg(curTemp, 0, res);
		System.out.println("\t MOVE " + resTemp + " HALLOCATE " + t);
		if (res.stackIndex != -1)
			System.out.println("\t ASTORE SPILLEDARG " + res.stackIndex + " " + resTemp);

		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Temp() f2 -> SimpleExp()
	 */
	public R visit(BinOp n, A argu) {
		R _ret = null;
		String op = (String) n.f0.accept(this, argu);
		int t1 = Integer.parseInt(n.f1.accept(this, argu) + "");
		String t2 = (String) n.f2.accept(this, argu);

		spillInfo res = new spillInfo();
		String resTemp = getReg(curTemp, 0, res);
		String printT1 = getReg(t1, 0, new spillInfo());

		System.out.println("\t MOVE " + resTemp + " " + op + " " + printT1 + " " + t2);
		if (res.stackIndex != -1)
			System.out.println("\t ASTORE SPILLEDARG " + res.stackIndex + " " + resTemp);
		return _ret;
	}

	/**
	 * f0 -> "LE" | "NE" | "PLUS" | "MINUS" | "TIMES" | "DIV"
	 */
	public R visit(Operator n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Temp() | IntegerLiteral() | Label()
	 */
	public R visit(SimpleExp n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		if (n.f0.which == 0) {
			// change v reg val
			return (R) getReg(Integer.parseInt(_ret + ""), 1, new spillInfo());
		}
		if (n.f0.which == 1) {
			System.out.println("\t MOVE v1 " + _ret);
			return (R) "v1";
		}
		return _ret;
	}

	/**
	 * f0 -> "TEMP" f1 -> IntegerLiteral()
	 */
	public R visit(Temp n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public R visit(IntegerLiteral n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public R visit(Label n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

}

