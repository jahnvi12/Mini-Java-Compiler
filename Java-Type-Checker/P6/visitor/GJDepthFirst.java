//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirst<R, A> implements GJVisitor<R, A> {
	//
	// Auto class visitors--probably don't need to be overridden.
	//
	String curReg = "";
	private int maxCalledArgs;
	private int nArgs;
	private int type;

	public R visit(NodeList n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeListOptional n, A argu) {
		if (n.present()) {
			R _ret = null;
			int _count = 0;
			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				e.nextElement().accept(this, argu);
				_count++;
			}
			return _ret;
		} else
			return null;
	}

	public R visit(NodeOptional n, A argu) {
		if (n.present()) {
			R label = n.node.accept(this, argu);
			if (label != null)
				System.out.println(label + ":");
			return label;
		} else
			return null;
	}

	public R visit(NodeSequence n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeToken n, A argu) {
		return (R) n.tokenImage;
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> "MAIN" f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> "[" f5 ->
	 * IntegerLiteral() f6 -> "]" f7 -> "[" f8 -> IntegerLiteral() f9 -> "]" f10 ->
	 * StmtList() f11 -> "END" f12 -> ( SpillInfo() )? f13 -> ( Procedure() )* f14
	 * -> <EOF>
	 */
	public R visit(Goal n, A argu) {

		Integer first, second, third;

		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		nArgs = first = Integer.parseInt(n.f2.accept(this, argu) + "");
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		second = Integer.parseInt(n.f5.accept(this, argu) + "");
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		maxCalledArgs = third = Integer.parseInt(n.f8.accept(this, argu) + "");
		Integer total = 4;
		if (third > 4)
			total += (third - 4) * 4;
		System.out.println("\t .text\n\t .globl\t main");
		System.out.println("main:");
		System.out.println("\t move $fp, $sp");
		System.out.println("\t subu $sp, $sp, " + total);
		System.out.println("\t sw $ra, -4($fp)");
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		System.out.println("\t lw $ra, -4($fp)");
		System.out.println("\t addu $sp, $sp, " + total);
		 System.out.println("li $v0 10\n syscall\n");
		//System.out.println("j $ra\n");
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		n.f13.accept(this, argu);
		n.f14.accept(this, argu);
		System.out.println("\t .text\n" + "\t .globl _halloc\n" + "_halloc:\n" + "\t li $v0, 9\n" + "\t syscall\n"
				+ "\t j $ra\n" + "\n" + "\t .text\n" + "\t .globl _print\n" + "_print:\n" + "\t li $v0, 1\n"
				+ "\t syscall\n" + "\t la $a0, newl\n" + "\t li $v0, 4\n" + "\t syscall\n" + "\t j $ra\n" + "\n"
				+ "\t .data\n" + "\t .align   0\n" + "newl:\t .asciiz \"\\n\" \n" + "\t .data\n" + "\t .align   0\n"
				+ "str_er:  .asciiz \" ERROR: abnormal termination\\n\" \n" + "");
		return _ret;
	}

	/**
	 * f0 -> ( ( Label() )? Stmt() )*
	 */
	public R visit(StmtList n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Label() f1 -> "[" f2 -> IntegerLiteral() f3 -> "]" f4 -> "[" f5 ->
	 * IntegerLiteral() f6 -> "]" f7 -> "[" f8 -> IntegerLiteral() f9 -> "]" f10 ->
	 * StmtList() f11 -> "END" f12 -> ( SpillInfo() )?
	 */
	public R visit(Procedure n, A argu) {

		Integer first, second, third;

		R _ret = null;
		String fnName = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		nArgs = first = Integer.parseInt(n.f2.accept(this, argu) + "");
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		second = Integer.parseInt(n.f5.accept(this, argu) + "");
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		maxCalledArgs = third = Integer.parseInt(n.f8.accept(this, argu) + "");
		Integer total = (second + 2) * 4;
		if (third > 4)
			total += (third - 1) * 4;
		System.out.println("\t .text\n\t .globl\t " + fnName);
		System.out.println(fnName + ":");
		System.out.println("\t sw $fp, -8($sp)");
		System.out.println("\t move $fp, $sp");
		System.out.println("\t subu $sp, $sp, " + total);
		System.out.println("\t sw $ra, -4($fp)");
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		System.out.println("\t lw $ra, -4($fp)");
		System.out.println("\t lw $fp, " + (total - 8) + "($sp)\n\t addu $sp, $sp, " + total + "\n\t j $ra\n");
		return _ret;
	}

	/**
	 * f0 -> NoOpStmt() | ErrorStmt() | CJumpStmt() | JumpStmt() | HStoreStmt() |
	 * HLoadStmt() | MoveStmt() | PrintStmt() | ALoadStmt() | AStoreStmt() |
	 * PassArgStmt() | CallStmt()
	 */
	public R visit(Stmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "NOOP"
	 */
	public R visit(NoOpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println("\t nop");
		return _ret;
	}

	/**
	 * f0 -> "ERROR"
	 */
	public R visit(ErrorStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		System.out.println("li $v0 4\nla $a0, str_er\nsyscall\n li $v0, 10\n syscall\n");
		return _ret;
	}

	/**
	 * f0 -> "CJUMP" f1 -> Reg() f2 -> Label()
	 */
	public R visit(CJumpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String reg = (String) n.f1.accept(this, argu);
		String label = (String) n.f2.accept(this, argu);
		System.out.println("\t beqz $" + reg + " " + label);
		return _ret;
	}

	/**
	 * f0 -> "JUMP" f1 -> Label()
	 */
	public R visit(JumpStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String label = (String) n.f1.accept(this, argu);
		System.out.println("\t b " + label);
		return _ret;
	}

	/**
	 * f0 -> "HSTORE" f1 -> Reg() f2 -> IntegerLiteral() f3 -> Reg()
	 */
	public R visit(HStoreStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String heap = (String) n.f1.accept(this, argu);
		String offset = (String) n.f2.accept(this, argu);
		String val = (String) n.f3.accept(this, argu);
		System.out.println("\t sw $" + val + ", " + offset + "($" + heap + ")");
		return _ret;
	}

	/**
	 * f0 -> "HLOAD" f1 -> Reg() f2 -> Reg() f3 -> IntegerLiteral()
	 */
	public R visit(HLoadStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String val = (String) n.f1.accept(this, argu);
		String heap = (String) n.f2.accept(this, argu);
		String offset = (String) n.f3.accept(this, argu);
		System.out.println("\t lw $" + val + ", " + offset + "($" + heap + ")");
		return _ret;
	}

	/**
	 * f0 -> "MOVE" f1 -> Reg() f2 -> Exp()
	 */
	public R visit(MoveStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		curReg = "" + n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "PRINT" f1 -> SimpleExp()
	 */
	public R visit(PrintStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		Integer choice = n.f1.f0.which;
		if (choice == 0)
			System.out.println("\t move $a0 $" + _ret);
		else if (choice == 1)
			System.out.println("\t li $a0 " + _ret);
		else
			System.out.println("\t la $a0 " + _ret);
		System.out.println("\t jal _print");
		return _ret;
	}

	/**
	 * f0 -> "ALOAD" f1 -> Reg() f2 -> SpilledArg()
	 */
	public R visit(ALoadStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t1 = (String) n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		System.out.println("\t lw $" + t1 + ", " + t2);
		return _ret;
	}

	/**
	 * f0 -> "ASTORE" f1 -> SpilledArg() f2 -> Reg()
	 */
	public R visit(AStoreStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t1 = (String) n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		System.out.println("\t sw $" + t2 + ", " + t1);
		return _ret;
	}

	/**
	 * f0 -> "PASSARG" f1 -> IntegerLiteral() f2 -> Reg()
	 */
	public R visit(PassArgStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		Integer index = Integer.parseInt("" + n.f1.accept(this, argu));
		String reg = (String) n.f2.accept(this, argu);
		System.out.println("\t sw $" + reg + ", " + (index - 1) * 4 + "($sp)");
		return _ret;
	}

	/**
	 * f0 -> "CALL" f1 -> SimpleExp()
	 */
	public R visit(CallStmt n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		if (n.f1.f0.which == 0)
			System.out.println("\t jalr $" + _ret);
		else
			System.out.println("\t jal " + _ret);
		return _ret;
	}

	/**
	 * f0 -> HAllocate() | BinOp() | SimpleExp()
	 */
	public R visit(Exp n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		if (n.f0.which == 2) {
			switch (type) {
			case 0:
				System.out.println("\t move $" + curReg + " $" + _ret);
				break;
			case 1:
				System.out.println("\t li $" + curReg + " " + _ret);
				break;
			case 2:
				System.out.println("\t la $" + curReg + " " + _ret);
				break;
			}
		}
		return _ret;
	}

	/**
	 * f0 -> "HALLOCATE" f1 -> SimpleExp()
	 */
	public R visit(HAllocate n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		if (n.f1.f0.which == 0)
			System.out.println("\t move $a0 $" + _ret);
		else
			System.out.println("\t li $a0 " + _ret);
		System.out.println("\t jal _halloc");
		System.out.println("\t move $" + curReg + " $v0");

		return _ret;
	}

	/**
	 * f0 -> Operator() f1 -> Reg() f2 -> SimpleExp()
	 */
	public R visit(BinOp n, A argu) {
		R _ret = null;
		String op = (String) n.f0.accept(this, argu);
		String reg = (String) n.f1.accept(this, argu);
		_ret = n.f2.accept(this, argu);
		if (type == 0)
			System.out.println("\t " + op + " $" + curReg + ", $" + reg + ", $" + _ret);
		if (type == 1) {
			System.out.println("\t " + op + " $" + curReg + ", $" + reg + ", " + _ret);
		}
		return _ret;
	}

	/**
	 * f0 -> "LE" | "NE" | "PLUS" | "MINUS" | "TIMES" | "DIV"
	 */
	public R visit(Operator n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		Integer ch = n.f0.which;
		switch (ch) {
		case 0:
			return (R) "sle";
		case 1:
			return (R) "sne";
		case 2:
			return (R) "add";
		case 3:
			return (R) "sub";
		case 4:
			return (R) "mul";
		case 5:
			return (R) "div";
		}
		return _ret;
	}

	/**
	 * f0 -> "SPILLEDARG" f1 -> IntegerLiteral()
	 */
	public R visit(SpilledArg n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		Integer index = Integer.parseInt((String) n.f1.accept(this, argu));
		if (nArgs > 4 && index < nArgs - 4)
			return (R) ((index * 4) + "($fp)");
		if (nArgs > 4)
			index -= (nArgs - 4);
		if (maxCalledArgs > 4)
			index += (maxCalledArgs - 4);
		index *= 4;
		return (R) (index + "($sp)");
	}

	/**
	 * f0 -> Reg() | IntegerLiteral() | Label()
	 */
	public R visit(SimpleExp n, A argu) {
		R _ret = null;
		type = n.f0.which;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "a0" | "a1" | "a2" | "a3" | "t0" | "t1" | "t2" | "t3" | "t4" | "t5" |
	 * "t6" | "t7" | "s0" | "s1" | "s2" | "s3" | "s4" | "s5" | "s6" | "s7" | "t8" |
	 * "t9" | "v0" | "v1"
	 */
	public R visit(Reg n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public R visit(IntegerLiteral n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public R visit(Label n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "//" f1 -> SpillStatus()
	 */
	public R visit(SpillInfo n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> <SPILLED> | <NOTSPILLED>
	 */
	public R visit(SpillStatus n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

}

