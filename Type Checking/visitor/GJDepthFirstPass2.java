//
// Generated by JTB 1.3.2
//
package visitor;

import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJDepthFirstPass2<R, A> extends GJDepthFirst<R, A> {
	boolean debug = false;
	HashMap<String, SymbolTable> Table;

	//
	// Auto class visitors--probably don't need to be overridden.
	//
	public R visit(NodeList n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeListOptional n, A argu) {
		if (n.present()) {
			R _ret = null;
			int _count = 0;
			LinkedList<R> list = new LinkedList<R>();

			for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
				list.add(e.nextElement().accept(this, argu));
				_count++;
			}
			return (R) list;
		} else
			return null;
	}

	public R visit(NodeOptional n, A argu) {
		if (n.present())
			return n.node.accept(this, argu);
		else
			return null;
	}

	public R visit(NodeSequence n, A argu) {
		R _ret = null;
		int _count = 0;
		for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
			e.nextElement().accept(this, argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeToken n, A argu) {
		return null;
	}

	//
	// User-generated visitor methods below
	//

	/**
	 * f0 -> MainClass() f1 -> ( TypeDeclaration() )* f2 -> <EOF>
	 */
	public R visit(Goal n, A argu) {

		R _ret = null;
		Table = (HashMap<String, SymbolTable>) argu;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		System.out.println("Program type checked successfully");
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> "public" f4 -> "static" f5
	 * -> "void" f6 -> "main" f7 -> "(" f8 -> "String" f9 -> "[" f10 -> "]" f11 ->
	 * Identifier() f12 -> ")" f13 -> "{" f14 -> PrintStatement() f15 -> "}" f16 ->
	 * "}"
	 */
	public R visit(MainClass n, A argu) {
		R _ret = null;
		SymbolTable curClass;
		n.f0.accept(this, argu);
		String name = (String) n.f1.accept(this, argu);
		curClass = Table.get(name);
		SymbolTable methodTable = curClass.method.get("main");
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		argu = (A) methodTable;
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		n.f8.accept(this, argu);
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		n.f13.accept(this, argu);
		n.f14.accept(this, argu);
		n.f15.accept(this, argu);
		n.f16.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> ClassDeclaration() | ClassExtendsDeclaration()
	 */
	public R visit(TypeDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "{" f3 -> ( VarDeclaration() )* f4 ->
	 * ( MethodDeclaration() )* f5 -> "}"
	 */
	public R visit(ClassDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String name = (String) n.f1.accept(this, argu);
		SymbolTable classTable = Table.get(name);
		argu = (A) classTable;
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "class" f1 -> Identifier() f2 -> "extends" f3 -> Identifier() f4 -> "{"
	 * f5 -> ( VarDeclaration() )* f6 -> ( MethodDeclaration() )* f7 -> "}"
	 */
	public R visit(ClassExtendsDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String name = (String) n.f1.accept(this, argu);
		SymbolTable classTable = Table.get(name);
		n.f2.accept(this, argu);
		String pName = (String) n.f3.accept(this, argu);
		if (!Table.containsKey(pName)) {
			if (debug)
				System.out.println(pName + " missing");
			System.out.println("Symbol not found");
			System.exit(0);
		}
		SymbolTable iter = classTable;
		while (iter.parenClass != null) {
			if (iter.parenClass == name) {
				if (debug)
					System.out.println("Circular dep");
				System.out.println("Type error");
				System.exit(0);
			}
			iter = Table.get(iter.parenClass);
		}
		argu = (A) classTable;
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Type() f1 -> Identifier() f2 -> ";"
	 */
	public R visit(VarDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	boolean match(String var, String exp) {
		if (var == exp)
			return true;
		SymbolTable iter = Table.get(exp);
		if (iter == null)
			return false;
		while (iter.parenClass != null) {
			if (var == iter.parenClass)
				return true;
			iter = Table.get(iter.parenClass);
		}
		return false;
	}

	/**
	 * f0 -> "public" f1 -> Type() f2 -> Identifier() f3 -> "(" f4 -> (
	 * FormalParameterList() )? f5 -> ")" f6 -> "{" f7 -> ( VarDeclaration() )* f8
	 * -> ( Statement() )* f9 -> "return" f10 -> Expression() f11 -> ";" f12 -> "}"
	 */
	public R visit(MethodDeclaration n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String retType = (String) n.f1.accept(this, argu);
		String mName = (String) n.f2.accept(this, argu);
		for (String s : Table.keySet()) {
			if (Table.get(s) == (SymbolTable) argu && s == mName) {
				if (debug)
					System.out.println("Wrong constructor " + mName);
				System.out.println("Type error");
				System.exit(0);
			}
		}

		SymbolTable methodTable = ((SymbolTable) argu).method.get(mName);
		SymbolTable iter = Table.get(((SymbolTable) argu).parenClass);
		LinkedList<String> curSignature = ((SymbolTable) argu).params.get(mName);
		String curRet = ((SymbolTable) argu).retType.get(mName);
		while (iter != null) {
			if (iter.method.containsKey(mName)) {
				LinkedList<String> thisSignature = iter.params.get(mName);
				String thisRet = iter.retType.get(mName);
				if (!match(thisRet, curRet)) {
					if (debug)
						System.out.println("Overriding " + mName);
					System.out.println("Type error");
					System.exit(0);
				}
				if (thisSignature.size() != curSignature.size()) {
					if (debug)
						System.out.println("Overriding " + mName);
					System.out.println("Type error");
					System.exit(0);
				}
				for (int i = 0; i < curSignature.size(); i++) {
					if (thisSignature.get(i) != curSignature.get(i)) {
						if (debug)
							System.out.println("Overriding " + mName);
						System.out.println("Type error");
						System.exit(0);
					}
				}
			}
			iter = Table.get(iter.parenClass);
		}
		argu = (A) methodTable;
		// TODO(jahnvi): Check what happens when function in parent class has same name
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
		n.f8.accept(this, argu);
		n.f9.accept(this, argu);
		String actualReturn = (String) n.f10.accept(this, argu);
		if (debug)
			System.out.println(actualReturn + " " + retType);
		if (!match(retType, actualReturn)) {
			if (debug)
				System.out.println("Return type mismatch for " + mName);
			System.out.println("Type error");
			System.exit(0);
		}
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> FormalParameter() f1 -> ( FormalParameterRest() )*
	 */
	public R visit(FormalParameterList n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Type() f1 -> Identifier()
	 */
	public R visit(FormalParameter n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "," f1 -> FormalParameter()
	 */
	public R visit(FormalParameterRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> ArrayType() | BooleanType() | IntegerType() | Identifier()
	 */
	public R visit(Type n, A argu) {
		R _ret = null;
		_ret = n.f0.accept(this, argu);
		if (n.f0.which == 3) {
			if (!Table.containsKey(_ret)) {
				if (debug)
					System.out.println(_ret + " undecl");
				System.out.println("Symbol not found");
				System.exit(0);
			}
		}
		return _ret;
	}

	/**
	 * f0 -> "int" f1 -> "[" f2 -> "]"
	 */
	public R visit(ArrayType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		_ret = (R) "int[]";
		return _ret;
	}

	/**
	 * f0 -> "boolean"
	 */
	public R visit(BooleanType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> "int"
	 */
	public R visit(IntegerType n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> Block() | AssignmentStatement() | ArrayAssignmentStatement() |
	 * IfStatement() | WhileStatement() | PrintStatement()
	 */
	public R visit(Statement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "{" f1 -> ( Statement() )* f2 -> "}"
	 */
	public R visit(Block n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	String idMatch(String id, SymbolTable T) {
		SymbolTable iter = T;
		while (T != null) {
			if (T.vars.containsKey(id))
				return T.vars.get(id);
			T = Table.get(T.parenClass);
		}
		if (debug)
			System.out.println(id + " undecl");
		System.out.println("Symbol not found");
		System.exit(0);
		return null;
	}

	/**
	 * f0 -> Identifier() f1 -> "=" f2 -> Expression() f3 -> ";"
	 */
	public R visit(AssignmentStatement n, A argu) {
		R _ret = null;
		String var = (String) n.f0.accept(this, argu);
		String varType = idMatch(var, (SymbolTable) argu);
		n.f1.accept(this, argu);
		String exp = (String) n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		if (!match(varType, exp)) {
			if (debug)
				System.out.println(var + " mismatch");
			System.out.println("Type error");
			System.exit(0);
		}
		return _ret;
	}

	/**
	 * f0 -> Identifier() f1 -> "[" f2 -> Expression() f3 -> "]" f4 -> "=" f5 ->
	 * Expression() f6 -> ";"
	 */
	public R visit(ArrayAssignmentStatement n, A argu) {
		R _ret = null;
		String var = (String) n.f0.accept(this, argu);
		String varType = idMatch(var, (SymbolTable) argu);
		n.f1.accept(this, argu);
		String indType = (String) n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		String assignType = (String) n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		if (varType != "int[]" || indType != "int" || assignType != "int") {
			if (debug)
				System.out.println(var + " mismatch");
			System.out.println("Type error");
			System.exit(0);
		}
		return _ret;
	}

	/**
	 * f0 -> IfthenElseStatement() | IfthenStatement()
	 */
	public R visit(IfStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public R visit(IfthenStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String cond = (String) n.f2.accept(this, argu);
		if (cond != "boolean") {
			if (debug)
				System.out.println("Bool cond expected");
			System.out.println("Type error");
			System.exit(0);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "if" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement() f5 ->
	 * "else" f6 -> Statement()
	 */
	public R visit(IfthenElseStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String cond = (String) n.f2.accept(this, argu);
		if (cond != "boolean") {
			if (debug)
				System.out.println("Bool cond expected");
			System.out.println("Type error");
			System.exit(0);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "while" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> Statement()
	 */
	public R visit(WhileStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String cond = (String) n.f2.accept(this, argu);
		if (cond != "boolean") {
			if (debug)
				System.out.println("Bool cond expected");
			System.out.println("Type error");
			System.exit(0);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> "System.out.println" f1 -> "(" f2 -> Expression() f3 -> ")" f4 -> ";"
	 */
	public R visit(PrintStatement n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String print = (String) n.f2.accept(this, argu);
		if (print != "int") {
			if (debug)
				System.out.println("Int print expected");
			System.out.println("Type error");
			System.exit(0);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> OrExpression() | AndExpression() | CompareExpression() |
	 * neqExpression() | PlusExpression() | MinusExpression() | TimesExpression() |
	 * DivExpression() | ArrayLookup() | ArrayLength() | MessageSend() |
	 * PrimaryExpression()
	 */
	public R visit(Expression n, A argu) {
		R _ret = null;
		return n.f0.accept(this, argu);
	}

	void bothSame(String t1, String t2, String toMatch) {
		if (t1 != toMatch || t2 != toMatch) {
			if (debug)
				System.out.println(t1 + " " + t2 + " " + toMatch);
			System.out.println("Type error");
			System.exit(0);
		}
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "&&" f2 -> PrimaryExpression()
	 */
	public R visit(AndExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "boolean");
		if (debug)
			System.out.println("and");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "||" f2 -> PrimaryExpression()
	 */
	public R visit(OrExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "boolean");
		if (debug)
			System.out.println("or");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "<=" f2 -> PrimaryExpression()
	 */
	public R visit(CompareExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		if (debug)
			System.out.println("leq");
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "!=" f2 -> PrimaryExpression()
	 */
	public R visit(neqExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		if (debug)
			System.out.println("neq");
		return (R) "boolean";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "+" f2 -> PrimaryExpression()
	 */
	public R visit(PlusExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "-" f2 -> PrimaryExpression()
	 */
	public R visit(MinusExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "*" f2 -> PrimaryExpression()
	 */
	public R visit(TimesExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "/" f2 -> PrimaryExpression()
	 */
	public R visit(DivExpression n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		bothSame(t1, t2, "int");
		return (R) t1;
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "[" f2 -> PrimaryExpression() f3 -> "]"
	 */
	public R visit(ArrayLookup n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String t2 = (String) n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		if (t1 != "int[]" || t2 != "int") {
			if (debug)
				System.out.println("Array ");
			System.out.println("Type error");
			System.exit(0);
		}
		return (R) "int";
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> "length"
	 */
	public R visit(ArrayLength n, A argu) {
		R _ret = null;
		String t1 = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if (t1 != "int[]") {
			if (debug)
				System.out.println("Array len");
			System.out.println("Type error");
			System.exit(0);
		}
		return (R) "int";
	}

	LinkedList<String> getParams(String mName, SymbolTable cTable) {
		while (cTable != null) {
			if (cTable.params.containsKey(mName))
				return cTable.params.get(mName);
			cTable = Table.get(cTable.parenClass);
		}
		if (debug)
			System.out.println(mName + " undecl or wrong scope");
		System.out.println("Symbol not found");
		System.exit(0);
		return null;
	}

	String getReturnType(String mName, SymbolTable cTable) {
		while (cTable != null) {
			if (debug)
				System.out.println(mName + " " + cTable.retType.get(mName));
			if (cTable.retType.containsKey(mName))
				return cTable.retType.get(mName);
			cTable = Table.get(cTable.parenClass);
		}
		if (debug)
			System.out.println(mName + " undecl or wrong scope");
		System.out.println("Symbol not found");
		System.exit(0);
		return null;
	}

	void matchParams(LinkedList<String> fp, LinkedList<String> ap) {
		boolean mat = true;
		if (fp.size() != ap.size())
			mat = false;
		for (int i = 0; i < fp.size(); i++) {
			if (!match(fp.get(i), ap.get(i))) {
				mat = false;
				break;
			}
		}
		if (!mat) {
			if (debug)
				System.out.println("FP != AP");
			System.out.println("Type error");
			System.exit(0);
		}
	}

	/**
	 * f0 -> PrimaryExpression() f1 -> "." f2 -> Identifier() f3 -> "(" f4 -> (
	 * ExpressionList() )? f5 -> ")"
	 */
	public R visit(MessageSend n, A argu) {
		R _ret = null;
		String cName = (String) n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		if (!Table.containsKey(cName)) {
			if (debug)
				System.out.println(cName + " Method call class missing");
			System.out.println("Symbol not found");
			System.exit(0);
		}
		SymbolTable classTable = Table.get(cName);
		String mName = (String) n.f2.accept(this, argu);
		LinkedList<String> formalParams = getParams(mName, classTable);
		n.f3.accept(this, argu);
		R _actualParams = n.f4.accept(this, argu);
		if (_actualParams == null)
			_actualParams = (R) new LinkedList<String>();
		LinkedList<String> actualParams = (LinkedList<String>) _actualParams;
		n.f5.accept(this, argu);
		matchParams(formalParams, actualParams);
		if (debug)
			System.out.println(mName + " " + getReturnType(mName, classTable));
		return (R) getReturnType(mName, classTable);
	}

	/**
	 * f0 -> Expression() f1 -> ( ExpressionRest() )*
	 */
	public R visit(ExpressionList n, A argu) {
		R _ret = null;
		LinkedList<String> list = new LinkedList<String>();
		String fp = (String) n.f0.accept(this, argu);
		R otherFp = n.f1.accept(this, argu);
		if (otherFp == null) {
			list.addFirst(fp);
			return (R) list;
		}
		list = (LinkedList<String>) otherFp;
		list.addFirst(fp);
		return (R) list;
	}

	/**
	 * f0 -> "," f1 -> Expression()
	 */
	public R visit(ExpressionRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> IntegerLiteral() | TrueLiteral() | FalseLiteral() | Identifier() |
	 * ThisExpression() | ArrayAllocationExpression() | AllocationExpression() |
	 * NotExpression() | BracketExpression()
	 */
	public R visit(PrimaryExpression n, A argu) {
		R _ret = null;
		String t = (String) n.f0.accept(this, argu);
		if (n.f0.which == 3) {
			if (Table.containsKey(t)) // class type
				return (R) t;
			return (R) idMatch(t, (SymbolTable) argu);
		}
		return (R) t;
	}

	/**
	 * f0 -> <INTEGER_LITERAL>
	 */
	public R visit(IntegerLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "int";
	}

	/**
	 * f0 -> "true"
	 */
	public R visit(TrueLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> "false"
	 */
	public R visit(FalseLiteral n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) "boolean";
	}

	/**
	 * f0 -> <IDENTIFIER>
	 */
	public R visit(Identifier n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		return (R) n.f0.toString();
	}

	/**
	 * f0 -> "this"
	 */
	public R visit(ThisExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		for (String key : Table.keySet()) {
			if (Table.get(key) == (SymbolTable) argu)
				return (R) key;
		}
		return (R) ((SymbolTable) argu).parenClass;
	}

	/**
	 * f0 -> "new" f1 -> "int" f2 -> "[" f3 -> Expression() f4 -> "]"
	 */
	public R visit(ArrayAllocationExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if ((String) n.f3.accept(this, argu) != "int") {
			if (debug)
				System.out.println("int exected");
			System.out.println("Type error");
			System.exit(0);
		}
		n.f4.accept(this, argu);
		return (R) "int[]";
	}

	/**
	 * f0 -> "new" f1 -> Identifier() f2 -> "(" f3 -> ")"
	 */
	public R visit(AllocationExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t = (String) n.f1.accept(this, argu);
		if (!Table.containsKey(t)) {
			if (debug)
				System.out.println(t + " undecls");
			System.out.println("Symbol not found");
			System.exit(0);
		}
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		return (R) t;
	}

	/**
	 * f0 -> "!" f1 -> Expression()
	 */
	public R visit(NotExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		String t = (String) n.f1.accept(this, argu);
		if (t != "boolean") {
			if (debug)
				System.out.println("not bool exected");
			System.out.println("Type error");
			System.exit(0);
		}
		return (R) t;
	}

	/**
	 * f0 -> "(" f1 -> Expression() f2 -> ")"
	 */
	public R visit(BracketExpression n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		return _ret;
	}

	/**
	 * f0 -> Identifier() f1 -> ( IdentifierRest() )*
	 */
	public R visit(IdentifierList n, A argu) {
		R _ret = null;
		LinkedList<String> list = new LinkedList<String>();
		String fp = (String) n.f0.accept(this, argu);
		R otherFp = n.f1.accept(this, argu);
		if (otherFp == null) {
			list.addFirst(fp);
			return (R) list;
		}
		list = (LinkedList<String>) otherFp;
		list.addFirst(fp);
		return (R) list;
	}

	/**
	 * f0 -> "," f1 -> Identifier()
	 */
	public R visit(IdentifierRest n, A argu) {
		R _ret = null;
		n.f0.accept(this, argu);
		_ret = n.f1.accept(this, argu);
		return _ret;
	}

}
